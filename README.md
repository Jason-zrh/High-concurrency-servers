# High-concurrency-servers
Inspired by muduo, a high concurency server. Surpport Http protacol.

# Reactor模型
服务端程序处理传入多路请求，是指通过一个或多个输入同时传递给服务器进行请求处理时的事件驱动处理模式。
并将它们同步分派给请求对应的处理线程，Reactor 模式也叫Dispatcher 模式。
简单理解就是使用 I/O多路复用 统一监听事件，收到事件后分发给处理进程或线程。

## 单Reactor单线程
1. 通过IO多路复用模型进行客户端请求监控
2. 触发事件后，进行事件处理
a. 如果是新建连接请求，则获取新建连接，并添加至多路复用模型进行事件监控。
b. 如果是数据通信请求，则进行对应数据处理（接收数据，处理数据，发送响应）。
优点：所有操作均在同一线程中完成，思想流程较为简单，不涉及进程/线程间通信及资源争抢问题。
缺点：无法有效利用CPU多核资源，很容易达到性能瓶颈。
适用场景：适用于客户端数量较少，且处理速度较为快速的场景。（处理较慢或活跃连接较多，会导致串行处理的情况下，后处理的连接长时间无法得到响应）。

## 单Reactor多线程
1. Reactor线程通过I/O多路复用模型进行客户端请求监控
2. 触发事件后，进行事件处理
a. 如果是新建连接请求，则获取新建连接，并添加至多路复用模型进行事件监控。
b. 如果是数据通信请求，则接收数据后分发给Worker线程池进行业务处理。
c. 工作线程处理完毕后，将响应交给Reactor线程进行数据响应
优点：充分利用CPU多核资源
缺点：多线程间的数据共享访问控制较为复杂，单个Reactor 承担所有事件的监听和响应，在单线程中运行，高并发场景下容易成为性能瓶颈。

## 多Reactor多线程
1. 在主Reactor中处理新连接请求事件，有新连接到来则分发到子Reactor中监控
2. 在子Reactor中进行客户端通信监控，有事件触发，则接收数据分发给Worker线程池
3. Worker线程池分配独立的线程进行具体的业务处理
a. 工作线程处理完毕后，将响应交给子Reactor线程进行数据响应
优点：充分利用CPU多核资源，主从Reactor各司其职

## One Thread one Loop主从Reactor模型实现高并发服务器
One Thread One Loop的思想就是把所有的操作都放到一个线程中进行，一个线程对应一个事件处理的循环。
当前实现中，因为并不确定组件使用者的使用意向，因此并不提供业务层工作线程池的实现，只实现主从Reactor，而Worker工作线程池，可由组件库的使用者的需要自行决定是否使用和实现。

## 功能模块的划分 - 两大模块(SERVER模块和协议模块)

### Server模块 - 高性能服务器

#### Buffer模块 : 缓冲区模块
提供功能: 存储数据，取出数据
实现思想:
1. 实现需要有一块内存空间vector<char> (ps: 为何不用string? string更多的是字符操作，遇到\0, '0' 会停止，在网络传输中可能遇到0产生干扰) vector底层采用的是线性的一块内存空间。
2. 要素:
- 默认空间大小
- 当前的读取数据位置
- 当前的写入数据位置
3. 操作:
- 写入: 写入位置指向哪里就从哪里开始写，如果空间不够了，则判断整体缓冲区中内存空间够不够，如果不够就重新扩容，如果够了则将已有数据移动到起始位置
- 读取: 从读取位置开始读取数据，可读数据大小 = 写入位置 - 读取位置

#### Socket模块

#### Channel模块

#### Connection模块

#### Acceptor模块

#### TimeQueue模块

#### Poller模块

#### EvenLoop模块

#### TcpServer模块

### 协议模块 - 为高性能服务器实现性能支持




## 代码实现

# Buffer模块

